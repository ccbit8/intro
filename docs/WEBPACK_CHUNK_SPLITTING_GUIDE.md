# 📏 Webpack Chunk 拆分黄金法则 (The Golden Rules of Code Splitting)

在进行性能优化时，我们经常面临一个问题：**代码到底要拆多细？** 

拆得太粗（Bundle 太大）会导致加载慢；拆得太细（Bundle 太多）会导致 HTTP 开销大。针对现代 HTTP/2 环境，业界总结出了一套黄金法则。

## 1. 黄金区间：30KB - 150KB (Gzipped) 🟢
这是最理想的 Chunk 大小。
*   **压缩效率高**: Gzip/Brotli 算法在处理中等大小的文本时压缩率最高。
*   **解析快**: 现代浏览器解析 100KB 的 JS 只需要几十毫秒。
*   **缓存友好**: 改动业务逻辑通常只影响其中一个 Chunk，不会导致所有缓存失效。

## 2. 可接受区间：150KB - 300KB 🟡
对于核心框架或大型库（如 `React + ReactDOM`，`Three.js`，`Recharts`），这个体积通常是不可避免的。
*   **策略**: 只要这些 Chunk 不阻塞首屏关键渲染（Non-blocking），或者使用了 `prefetch/preload`，是可以接受的。

## 3. 危险区间：> 350KB 🔴
这就是为什么我们需要在 `next.config.js` 中强制拆分 `recharts` 的原因。
*   **主线程阻塞**: 解析和编译 (Parse & Compile) 巨型 JS 文件会长时间占用主线程，导致页面"卡死"（TBT - Total Blocking Time 飙升）。
*   **带宽浪费**: 用户可能只访问首页，却被迫下载了后台管理系统的代码。

## 4. 碎片区间：< 10KB ⚪
**不要为了拆分而拆分。** 如果拆出几十个 1KB 的文件，反而是负优化。
*   **HTTP 开销**: 请求头（Headers）的体积可能比文件本身还大。
*   **压缩效率低**: 小文本很难被高效压缩。

## 5. 实战案例：我们的项目现状
经过优化后，我们的项目完美契合了这一法则：

| Chunk 名称 | 大小 | 状态 | 说明 |
| :--- | :--- | :--- | :--- |
| **Main Bundle** | ~200KB | ✅ 正常 | 包含 React 核心运行时 |
| **Recharts Chunk** | ~500KB | 🟡 即使大但安全 | 单独拆分，仅在图表页异步加载，不阻塞首页 |
| **Vendors (Shared)** | ~50KB | ✅ 完美 | 包含 socket.io 等共享库，处于黄金区间 |
| **Lucide Icons** | < 5KB | ✅ 极致 | Tree Shaking生效，按需散落在各处 |

---

> **总结**: 优化的目标不是"Chunk 数量越多越好"，而是让**首屏需要加载的 JS 总量最小**，同时保持单个 Chunk 的体积适中。
